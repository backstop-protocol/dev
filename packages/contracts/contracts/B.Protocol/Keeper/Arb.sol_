// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;
pragma experimental ABIEncoderV2;


interface UniswapReserve {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface UniswapV2Router01 {
    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);
}

interface ERC20Like {
    function approve(address spender, uint value) external returns(bool);
    function transfer(address to, uint value) external returns(bool);
    function balanceOf(address a) external view returns(uint);
}

interface WethLike is ERC20Like {
    function deposit() external payable;
}

interface BAMMLike {
    function swap(uint lusdAmount, uint minEthReturn, address payable dest) external returns(uint);
    function LUSD() external view returns(address);
}

contract Arb {
    UniswapV2Router01 immutable router;
    ERC20Like immutable WETH;

    constructor(address _router, address _WETH) public {
        router = UniswapV2Router01(_router);
        WETH = ERC20Like(_WETH);
    }

    function approve(address dst, ERC20Like token) external {
        // callable by anyone, but the contract will never hold funds
        token.approve(address(dst), uint(-1));
    }

    function getPrice(uint wethQty, address destToken) public returns(uint) {
        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = destToken;
        address[] memory amounts = router.getAmountsOut(wethQty, path);
        return amounts[1];
    }

    function swap(uint ethQty, address bamm, address USD, address USDETH) external payable returns(uint) {
        uint usdQty = getPrice(ethQty, USD);
        bytes memory data = abi.encode(bamm, ethQty, usdQty);
        USDETH.swap(0, usdQty, address(this), data);

        uint retVal = address(this).balance;
        msg.sender.transfer(retVal);

        return retVal;
     }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        (address bamm, uint ethQty, uint usdQty) = abi.decode(data, (address, uint, uint));

        BAMMLike.swap(usdQty, 1, address(this));
        WethLike(WETH).deposit{value: ethQty}();
        WethLike(WETH).transfer(msg.sender, ethQty);
    }

    receive() external payable {}
}

contract ArbChecker {
    Arb immutable public arb;
    constructor(Arb _arb) public {
        arb = _arb;
    }

    function checkProfitableArb(uint ethQty, uint minProfit, address bamm, address USD, address USDETH) public { // revert on failure
        uint balanceBefore = address(this).balance;
        arb.swap(ethQty, bamm, USD, USDETH);
        uint balanceAfter = address(this).balance;
        require((balanceAfter - balanceBefore) >= minProfit, "min profit was not reached");
    }

    receive() external payable {}       
}

contract BKeeper {
    address public masterCopy;
    ArbChecker immutable public arbChecker;
    Arb immutable public arb;
    uint maxEthQty; // = 1000 ether;
    uint minQty; // = 1e10;
    uint minProfitInBps; // = 100;

    address public admin;
    address[] public bamms;
    mapping(address => address) public USD; // bamm to usd address
    mapping(address => address) public router; // bamm to router

    event KeepOperation(bool succ);

    constructor(Arb _arb, ArbChecker _arbChecker) public {
        arbChecker = ArbChecker(_arbChecker);
        arb = _arb;
    }

    function findSmallestQty() public returns(uint, address) {
        for(uint i = 0 ; i < bamms.length ; i++) {
            address bamm = bamms[i];
            for(uint qty = maxEthQty ; qty > minQty ; qty = qty / 2) {
                uint minProfit = qty * minProfitInBps / 10000;
                try arbChecker.checkProfitableArb(qty, minProfit, bamm, LUSD[bamm], router[bamm]) {
                    return (qty, bamm);
                } catch {

                }
            }
        }

        return (0, address(0));
    }

    function checkUpkeep(bytes calldata /*checkData*/) external returns (bool upkeepNeeded, bytes memory performData) {
        uint[] memory balances = new uint[](bamms.length);
        for(uint i = 0 ; i < bamms.length ; i++) {
            balances[i] = bamms[i].balance;
        }

        (uint qty, address bamm) = findSmallestQty();

        uint bammBalance;
        for(uint i = 0 ; i < bamms.length ; i++) {
            if(bamms[i] == bamm) bammBalance = balances[i];
        }

        upkeepNeeded = qty > 0;
        performData = abi.encode(qty, bamm, bammBalance);
    }
    
    function performUpkeep(bytes calldata performData) external {
        (uint qty, address bamm, uint bammBalance) = abi.decode(performData, (uint, address, uint));
        require(bammBalance == bamm.balance, "performUpkeep: front runned");
        require(qty > 0, "0 qty");
        arb.swap(qty, bamm, LUSD[bamm], router[bamm]);
        
        emit KeepOperation(true);        
    }

    function performUpkeepSafe(bytes calldata performData) external {
        try this.performUpkeep(performData) {
            emit KeepOperation(true);
        }
        catch {
            emit KeepOperation(false);
        }
    }    

    receive() external payable {}

    // admin stuff
    function transferAdmin(address newAdmin) external {
        require(msg.sender == admin, "!admin");
        admin = newAdmin;
    }

    function initParams(uint _maxEthQty, uint _minEthQty, uint _minProfit) external {
        require(admin == address(0), "already init");
        maxEthQty = _maxEthQty;
        minQty = _minEthQty;
        minProfitInBps = _minProfit;

        admin = msg.sender;        
    }

    function setMaxEthQty(uint newVal) external {
        require(msg.sender == admin, "!admin");
        maxEthQty = newVal;        
    }

    function setMinEthQty(uint newVal) external {
        require(msg.sender == admin, "!admin");
        minQty = newVal;        
    }
    
    function setMinProfit(uint newVal) external {
        require(msg.sender == admin, "!admin");
        minProfitInBps = newVal;        
    }

    function addBamm(address newBamm, address newRouter) external {
        require(msg.sender == admin, "!admin");        
        arb.approve(newBamm);
        bamms.push(newBamm);

        LUSD[newBamm] = BAMMLike(newBamm).LUSD();
        router[newBamm] = newRouter;
    }

    function removeBamm(address bamm) external {
        require(msg.sender == admin, "!admin");
        for(uint i = 0 ; i < bamms.length ; i++) {
            if(bamms[i] == bamm) {
                bamms[i] = bamms[bamms.length - 1];
                bamms.pop();

                return;
            }
        }

        revert("bamm does not exist");
    }

    function withdrawEth() external {
        require(msg.sender == admin, "!admin");
        msg.sender.transfer(address(this).balance);        
    }

    function upgrade(address newMaster) public {
        require(msg.sender == admin, "!admin");
        masterCopy = newMaster;        
    }
}

contract KeeperProxy {

    // masterCopy always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.
    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`
    address public masterCopy;

    /// @dev Constructor function sets address of master copy contract.
    /// @param _masterCopy Master copy address.
    constructor(address _masterCopy)
        public
    {
        require(_masterCopy != address(0), "Invalid master copy address provided");
        masterCopy = _masterCopy;
    }

    /// @dev Fallback function forwards all transactions and returns all received return data.
    fallback() external payable
    {
        // solium-disable-next-line security/no-inline-assembly
        address impl = masterCopy;

        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
            // delegatecall returns 0 on error.
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }
}

interface KeeperLike {
    function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);
    function performUpkeepSafe(bytes calldata performData) external;
    function performUpkeep(bytes calldata performData) external;    
}

contract BGelato {
    KeeperLike immutable public proxy;

    constructor(KeeperLike _proxy) public {
        proxy = _proxy;
    }

    function checker()
        external
        returns (bool canExec, bytes memory execPayload)
    {
        (bool upkeepNeeded, bytes memory performData) = proxy.checkUpkeep(bytes(""));
        canExec = upkeepNeeded;

        execPayload = abi.encodeWithSelector(
            BGelato.doer.selector,
            performData
        );
    }

    function doer(bytes calldata performData) external {
        proxy.performUpkeepSafe(performData);
    }

    function test(bytes calldata input) external {
        address(this).call(input);
    }
}


// sushi router 0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506
// 